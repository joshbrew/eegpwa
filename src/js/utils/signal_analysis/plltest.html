<html>
<head>
<script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/1.33.1/plotly.min.js"></script>
</head>
<body>
    F12 to open console and see results
    <h3 id="string1"></h3>
    Sine wave in:
    <div id="sinechart"></div>
    <h3 id="string2"></h3>
    Mixed amplitudes out:
    <div id="mixedchart"></div>
    Frequency adjustments:
    <div id="freqchart"></div>
    Phase adjustments:
    <div id="phasechart"></div>
    <script>




    let freq_actual = 1.2;
    let freq_guess_in = 1.5;
    let α = 0.1; //Phase offset multiplier
    let ß = 0.5; //Frequency offset multiplier. Beta is multiplied by alpha squared in the algorithm
    let fs = 512; //Sample rate (sps)
    let nSec = 100; //Seconds of sine wave to compute
    
    let nsamples = Math.floor(fs*nSec);

    let wave = genSineWave(freq_actual,1,nSec,fs,7,0.1);
    let wave_amps = wave[1];
    let wave_t = wave[0];

    let string1 = freq_actual+'Hz sine in, guess '+freq_guess_in+'Hz to start. α='+α+', ß='+ß+'*α^2';

    console.log(string1);//,//wave)
    document.getElementById("string1").innerHTML = string1;

    let dftpll_result = DFTpll(wave_amps,fs,nsamples,freq_guess_in,0,α,ß)

    let string2 = "PLL RESULT: Freq_guessed (Hz): "+ dftpll_result.freq_guesses[nsamples-1].toFixed(4)+"Hz, Phase guessed (rad):" + dftpll_result.phase_guesses[nsamples-1].toFixed(4) + ", Phase error: "+dftpll_result.phase_errs[nsamples-1].toFixed(4);
    document.getElementById("string2").innerHTML = string2;

    console.log(string2);
    console.log("Mixing result: ", dftpll_result.mixed)

    let pll = PLL4thOrder(wave_amps, 1.5, 1);
    console.log("4th order PLL", pll)



    let data = [[{
              x: wave_t,
              y: wave_amps,
              type: 'line',
              marker: {
                color: "rgba(255,100,100, 1)"
              },
              name: "Sine",
              //xbins: {  size: 0.01  }
            }],[{
                x:wave_t,
                y:dftpll_result.mixed,
                type: 'line',
                marker: {
                    color: "rgba(100,255,100, 1)"
                },
                name: 'Mixed',    
                xbins: {  size: 1  }
            }],[{
                x:wave_t,
                y:dftpll_result.freq_guesses,
                type: 'line',
                marker: {
                    color: "rgba(255,155,0, 1)"
                },
                name: 'Mixed',    
                xbins: {  size: 1  }
            }],[{
                x:wave_t,
                y:pll.mixed,
                type: 'line',
                marker: {
                    color: "rgba(100,255,255, 1)"
                },
                name: 'Mixed',    
                xbins: {  size: 1  }
            }]];

    let config = { 
        scrollZoom: true, 
        responsive: true, 
    }
    
    Plotly.newPlot("sinechart",data[0],undefined,config);
    Plotly.newPlot("mixedchart",data[1],undefined,config);
    Plotly.newPlot("freqchart",data[2],undefined,config);
    Plotly.newPlot("phasechart",data[3],undefined,config);


function genSineWave(freq=20,peakAmp=1,nSec=1,fs=512,freq2=0,peakAmp2=1){
        var sineWave = [];
        var t = [];
        var increment = 1/fs; //x-axis time increment based on sample rate
        for (var ti = 0; ti < nSec; ti+=increment){
            var amplitude = Math.sin(2*Math.PI*freq*ti)*peakAmp;
            amplitude += Math.sin(2*Math.PI*freq2*ti)*peakAmp2; //Add interference
            sineWave.push(amplitude);
            t.push(ti);
        }
        return [t,sineWave]; // [[times],[amplitudes]]
    }
    


function DFTpll(signal=genSineWave(3.3,1,1,512)[1], fs=512, len=512, freq_est=3, dcoffset=0, alpha=0.05, beta=0.5){ //modifed DFT equation for extracting a single frequency mixed with a simulated frequency, trying to minimze error
    var real = 0;
    var imag = 0;
    var real_sim = 0;
    var imag_sim = 0;
    var _len = 1/len;
    var _fs = 1/fs;
    var freq = freq_est;

    var α = alpha;
    var ß = beta*α*α;
    const TWO_PI = 2*Math.PI;
    //var shared = TWO_PI*freq*_len;
    var phase_out = 0;
    var mixed_signal = new Array(len).fill(0);
    var freq_guesses = new Array(len).fill(0);
    var phase_guesses = new Array(len).fill(0);
    var phase_err_results = new Array(len).fill(0);

    for(var i = 0; i<len; i++){
      var sharedi =TWO_PI*freq*_fs*i; //complex exponent component
      real = real+(signal[i]-dcoffset)*Math.cos(sharedi); //complex exponent operations to convert the signal to an amplitude based on the input frequency
      imag = imag-(signal[i]-dcoffset)*Math.sin(sharedi);

      var simulated = Math.sin(sharedi + phase_out); //Generate sine amplitude with the modulating parameters
      real_sim = real_sim+(simulated)*Math.cos(sharedi + phase_out);
      imag_sim = imag_sim-(simulated)*Math.sin(sharedi + phase_out);

      //Complex multiplication (mixing the signals)
      let re = real*real_sim + imag*imag_sim; //conjugated imag_sim.
      let im = -real*imag_sim + imag*real_sim; //conjugated imag_sim.
      let phase_err = 0;
      if(re !== 0 ){
        phase_err = Math.atan(im/re);//complex argument
      }
      else if (im < 0) {
        phase_err = -Math.PI/2;
      }
      else if (im > 0) {
        phase_err = Math.PI/2;
      }
      else {
        phase_err = 0;
      }

      freq += phase_err * ß; //ß
      phase_out += phase_err * α; //α
      if(phase_out > TWO_PI)
      {
          phase_out -= TWO_PI;
      }
      else if (phase_out < 0) {
        phase_out += TWO_PI;
      }


      var mag = Math.sqrt(re*re+im*im);

      mixed_signal[i] = mag*_len;
      freq_guesses[i] = freq;
      phase_guesses[i] = phase_out;
      phase_err_results[i] = phase_err;
      
    }

    return {mixed:mixed_signal, freq_guesses:freq_guesses, phase_guesses:phase_guesses, phase_errs:phase_err_results}; //mag(real,imag)

}



//lifted from https://github.com/SukneungBae/SDRAngelCopied/blob/ffa604cecf668e0f349e27aa814643b1c3fa4462/sdrbase/dsp/phaselock.cpp
function PLL4thOrder(samples, freq_guess, bandwidth) {

  //min/max
  const TWO_PI = 2*Math.PI;
  let minfreq = (freq_guess-bandwidth)*TWO_PI;
  let maxfreq = (freq_guess+bandwidth)*TWO_PI;

  //threshold
  let psin = 0;
  let pcos = 1;

  //2nd order filter
  let p1 = Math.exp(-1.146*bandwidth*TWO_PI);
  let p2 = Math.exp(-5.331*bandwidth*TWO_PI);
  let phasor_a1 = -p1 - p2;
  let phasor_a2 = p1*p2;
  let phasor_b0 = 1 + phasor_a1 + phasor_a2;

  //loop filter
  let q1 = Math.exp(-0.1153*bandwidth*TWO_PI);
  let loop_b0 = 0.62*bandwidth*TWO_PI;
  let loop_b1 = -loop_b0*q1;

  //init freq and phase
  let freq = freq_guess*TWO_PI;
  let phase = 0;
  let phasor_i1 = 0;
  let phasor_i2 = 0;
  let phasor_q1 = 0;
  let phasor_q2 = 0;
  let loop_x1 = 0;


  let output = new Array(samples.length).fill(0);

  for(let i = 0; i < samples.length; i++) {
    
    psin = Math.sin(phase);
    pcos = Math.cos(phase);

    output[i] = 2*psin*pcos;

    let x = samples[i];
    let phasor_i = psin*x;
    let phasor_q = pcos*x;

    //low pass filters for phasors
    phasor_i = phasor_b0*phasor_i -
               phasor_a1*phasor_i1 -
               phasor_a2* phasor_i2;

    phasor_q = phasor_b0*phasor_q -
               phasor_a1*phasor_q1 -
               phasor_a2*phasor_q2;

    phasor_i2 = phasor_i1;
    phasor_i1 = phasor_i;
    phasor_q2 = phasor_q1;
    phasor_q1 = phasor_q;

    let phase_err = 0;
    if(phasor_i > Math.abs(phasor_q)){ 
      phase_err = phasor_q / phasor_i;
    }
    else if (phasor_q > 0) {
      phase_err = 1;
    }
    else {
      phase_err = -1;
    }


    freq += loop_b0 * phase_err + loop_b1*loop_x1;
    loop_x1 = phase_err;

    freq = Math.max(minfreq,Math.min(maxfreq,freq));
    
    phase += freq;
    if(phase > TWO_PI) {
      phase -= TWO_PI;
    }


  }

  return {mixed:output,freq_guess:freq/TWO_PI, phase:phase};

}




    
    </script>
</body>

</html>