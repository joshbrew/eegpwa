<html>
<head>
<script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/1.33.1/plotly.min.js"></script>
</head>
<body>
    F12 to open console and see results
    <h3 id="string1"></h3>
    Sine wave in:
    <div id="sinechart"></div>
    <h3 id="string2"></h3>
    dft pll output:
    <div id="mixedchart"></div>
    dft pll Frequency adjustments:
    <div id="freqchart"></div>
    dpll output:
    <div id="dpllchart"></div>
    <script>




    let freq_actual = 1.2;
    let freq_guess_in = 1.5;
    let α = 0.05; //Phase offset multiplier
    let ß = 0.4; //Frequency offset multiplier. Beta is multiplied by alpha squared in the algorithm
    let fs = 512; //Sample rate (sps)
    let nSec = 3; //Seconds of sine wave to compute
    
    let nsamples = Math.floor(fs*nSec);

    let wave = genSineWave(freq_actual,1,nSec,fs);
    let wave_amps = wave[1];
    let wave_t = wave[0];

    let string1 = freq_actual+'Hz sine in, guess '+freq_guess_in+'Hz to start. α='+α+', ß='+ß+'*α^2';

    console.log(string1);//,//wave)
    document.getElementById("string1").innerHTML = string1;

    let dftpll_result = DFTpll(wave_amps,fs,nsamples,freq_guess_in,0,α,ß)

    let string2 = "PLL RESULT: Freq_guessed (Hz): "+ dftpll_result.freq_guesses[nsamples-1].toFixed(4)+"Hz, Phase guessed (rad):" + dftpll_result.phase_guesses[nsamples-1].toFixed(4) + ", Phase error: "+dftpll_result.phase_errs[nsamples-1].toFixed(4);
    document.getElementById("string2").innerHTML = string2;

    console.log(string2);
    console.log("Mixing result: ", dftpll_result.mixed)

    let dpll_result = my_dpll(wave_amps,freq_guess_in);

    console.log(dpll_result);


    let data = [[{
              x: wave_t,
              y: wave_amps,
              type: 'line',
              marker: {
                color: "rgba(255,100,100, 1)"
              },
              name: "Sine",
              //xbins: {  size: 0.01  }
            }],[{
                x:wave_t,
                y:dftpll_result.mixed,
                type: 'line',
                marker: {
                    color: "rgba(100,255,100, 1)"
                },
                name: 'Mixed',    
                xbins: {  size: 1  }
            }],[{
                x:wave_t,
                y:dftpll_result.freq_guesses,
                type: 'line',
                marker: {
                    color: "rgba(255,155,0, 1)"
                },
                name: 'Mixed',    
                xbins: {  size: 1  }
            }],[{
                x:wave_t,
                y:dpll_result.estimated,
                type: 'line',
                marker: {
                    color: "rgba(255,55,125, 1)"
                },
                name: 'Mixed',    
                xbins: {  size: 1  }
            }]
          ];

    let config = { 
        scrollZoom: true, 
        responsive: true, 
    }
    
    Plotly.newPlot("sinechart",data[0],undefined,config);
    Plotly.newPlot("mixedchart",data[1],undefined,config);
    Plotly.newPlot("freqchart",data[2],undefined,config);
    Plotly.newPlot("dpllchart",data[3],undefined,config);


function genSineWave(freq=20,peakAmp=1,nSec=1,fs=512,freq2=0,peakAmp2=1){
        var sineWave = [];
        var t = [];
        var increment = 1/fs; //x-axis time increment based on sample rate
        for (var ti = 0; ti < nSec; ti+=increment){
            var amplitude = Math.sin(2*Math.PI*freq*ti)*peakAmp;
            amplitude += Math.sin(2*Math.PI*freq2*ti)*peakAmp2; //Add interference
            sineWave.push(amplitude);
            t.push(ti);
        }
        return [t,sineWave]; // [[times],[amplitudes]]
    }
    


function DFTpll(signal=genSineWave(3.3,1,1,512)[1], fs=512, len=512, freq_est=3, dcoffset=0, alpha=0.05, beta=0.5){ //modifed DFT equation for extracting a single frequency mixed with a simulated frequency, trying to minimze error
    var real = 0;
    var imag = 0;
    var real_sim = 0;
    var imag_sim = 0;
    var _len = 1/len;
    var _fs = 1/fs;
    var freq = freq_est;

    var α = alpha;
    var ß = beta*α*α;
    const TWO_PI = 2*Math.PI;
    //var shared = TWO_PI*freq*_len;
    var phase_out = 0;
    var mixed_signal = new Array(len).fill(0);
    var freq_guesses = new Array(len).fill(0);
    var phase_guesses = new Array(len).fill(0);
    var phase_err_results = new Array(len).fill(0);

    for(var i = 0; i<len; i++){
      var sharedi =TWO_PI*freq*_fs*i; //complex exponent component
      real = real+(signal[i]-dcoffset)*Math.cos(sharedi); //complex exponent operations to convert the signal to an amplitude based on the input frequency
      imag = imag-(signal[i]-dcoffset)*Math.sin(sharedi);

      var simulated = Math.sin(sharedi + phase_out); //Generate sine amplitude with the modulating parameters
      real_sim = real_sim+(simulated)*Math.cos(sharedi + phase_out);
      imag_sim = imag_sim-(simulated)*Math.sin(sharedi + phase_out);

      //Complex multiplication (mixing the signals)
      let re = real*real_sim + imag*imag_sim; //conjugated imag_sim.
      let im = -real*imag_sim + imag*real_sim; //conjugated imag_sim.
      let phase_err = 0;
      if(re !== 0 ){
        phase_err = Math.atan(im/re);//complex argument
      }
      else if (im < 0) {
        phase_err = -Math.PI/2;
      }
      else if (im > 0) {
        phase_err = Math.PI/2;
      }
      else {
        phase_err = 0;
      }

      freq += phase_err * ß; //ß
      phase_out += phase_err * α; //α
      if(phase_out > TWO_PI)
      {
          phase_out -= TWO_PI;
      }
      else if (phase_out < 0) {
        phase_out += TWO_PI;
      }


      var mag = Math.sqrt(re*re+im*im);

      mixed_signal[i] = mag*_len;
      freq_guesses[i] = freq;
      phase_guesses[i] = phase_out;
      phase_err_results[i] = phase_err;
      
    }

    return {mixed:mixed_signal, freq_guesses:freq_guesses, phase_guesses:phase_guesses, phase_errs:phase_err_results}; //mag(real,imag)

}

function my_dpll(signal_in, expectedFreq=4) {
  let α = 0.05;    //Phase modulation scalar
  let ß = .01;    //Frequency modulation scalar
  var phase_out = 0;
  var freq=expectedFreq,
      peakAmp=Math.max(...signal_in),
      floor=Math.min(...signal_in),
      fs=512;
  var sineWave = [];
  var t = 0;
  var increment = 1/fs; //x-axis time increment based on sample rate
  let phase_err = 0;
  var im = 0;
  for(var i = 0; i < signal_in.length; i++) {
      t=increment*i;
      var simulated = Math.sin(2*Math.PI*freq*t + phase_out); //Generate sine amplitude with the modulating parameters
      mag = Math.sqrt(simulated*simulated + im*im); //; convert re, im to polar (mag, phi)
      phi = Math.atan2(im, simulated);
      mag = mag * peakAmp;      //; apply factor `scale` to magnitude
      im = mag * Math.sin(phi);
      var cmulr = signal_in[i]*simulated; //throwing out the multiplication of the signal in imaginary number as we set it to 0
      var cmuli = signal_in[i]*im;
      if(cmulr === 0) { 
          phase_err = 0.0;
      } else { 
          phase_err = Math.atan(cmuli/cmulr);
      }
      phase_out += α*phase_err; //Correct parameters by the error
      freq += ß*phase_err;
      //console.log(simulated,phi,im,phase_err,phase_out,freq);
      sineWave.push(simulated);
  }
  return {estimated:sineWave,phase_err:phase_err,freq_est:freq,phase_est:phase_out};
}

    
    </script>
</body>

</html>