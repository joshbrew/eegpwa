!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e(require("d3-color"),require("d3-scale"),require("d3-selection"),require("d3-axis")):"function"==typeof define&&define.amd?define(["d3-color","d3-scale","d3-selection","d3-axis"],e):(t="undefined"!=typeof globalThis?globalThis:t||self).TimeChart=e(t.d3,t.d3,t.d3,t.d3)}(this,(function(t,e,i,s){"use strict";function n(t,e,i,s,n){if(e>=i)return e;if(s<=n(t[e]))return e;if(s>n(t[i-1]))return i;for(i-=1;e+1<i;){const o=n(t[e]),a=n(t[i]),r=a<=o?0:(s-o)/(a-o);let h=Math.ceil(e+r*(i-e));h===i?h--:h===e&&h++;n(t[h])<s?e=h:i=h}return i}class o{constructor(){this.callbacks=[]}on(t){this.callbacks.push(t)}dispatch(...t){for(const e of this.callbacks)e(...t)}}class a{constructor(t){this.options=t,this.xScale=e.scaleLinear(),this.yScale=e.scaleLinear(),this.xRange=null,this.yRange=null,this.seriesInfo=new Map,this.resized=new o,this.updated=new o,this.disposing=new o,this.disposed=!1,this.redrawRequested=!1,"auto"!==t.xRange&&t.xRange&&this.xScale.domain([t.xRange.min,t.xRange.max]),"auto"!==t.yRange&&t.yRange&&this.yScale.domain([t.yRange.min,t.yRange.max])}resize(t,e){const i=this.options;this.xScale.range([i.paddingLeft,t-i.paddingRight]),this.yScale.range([e-i.paddingBottom,i.paddingTop]),this.resized.dispatch(t,e),this.requestRedraw()}dispose(){this.disposed||(this.disposing.dispatch(),this.disposed=!0)}update(){this.updateModel(),this.updated.dispatch()}updateModel(){var t,e;for(const t of this.options.series)this.seriesInfo.has(t)||this.seriesInfo.set(t,{yRangeUpdatedIndex:0});const i=this.options.series.filter((t=>t.data.length>0));if(0===i.length)return;const s=this.options.xRange,n=this.options.yRange;{const n=Math.max(...i.map((t=>t.data[t.data.length-1].x))),o=null!==(e=null===(t=this.xRange)||void 0===t?void 0:t.min)&&void 0!==e?e:Math.min(...i.map((t=>t.data[0].x)));if(this.xRange={max:n,min:o},this.options.realTime||"auto"===s)if(this.options.realTime){const t=this.xScale.domain(),e=t[1]-t[0];this.xScale.domain([n-e,n])}else this.xScale.domain([o,n]);else s&&this.xScale.domain([s.min,s.max])}{const t=i.map((t=>function(t){let e=-1/0,i=1/0;for(const s of t)s>e&&(e=s),s<i&&(i=s);return{max:e,min:i}}(t.data.slice(this.seriesInfo.get(t).yRangeUpdatedIndex).map((t=>t.y)))));this.yRange&&t.push(this.yRange);const e=Math.min(...t.map((t=>t.min))),s=Math.max(...t.map((t=>t.max)));if(this.yRange={max:s,min:e},"auto"===n){this.yScale.domain([e,s]).nice();for(const t of i)this.seriesInfo.get(t).yRangeUpdatedIndex=t.data.length}else n&&this.yScale.domain([n.min,n.max])}}requestRedraw(){this.redrawRequested||(this.redrawRequested=!0,requestAnimationFrame((t=>{this.redrawRequested=!1,this.disposed||this.update()})))}pxPoint(t){return{x:this.xScale(t.x),y:this.yScale(t.y)}}}var r="undefined"!=typeof Float32Array?Float32Array:Array;function h(){var t=new r(2);return r!=Float32Array&&(t[0]=0,t[1]=0),t}Math.hypot||(Math.hypot=function(){for(var t=0,e=arguments.length;e--;)t+=arguments[e]*arguments[e];return Math.sqrt(t)});var l;l=h();function d(t,e,i,s){var n;const o=c(t.createShader(e));if(t.shaderSource(o,i),t.compileShader(o),s){if(!t.getShaderParameter(o,t.COMPILE_STATUS)){const e=null!==(n=t.getShaderInfoLog(o))&&void 0!==n?n:"Unknown Error.";throw t.deleteShader(o),new Error(e)}}return o}function c(t){if(!t)throw new Error("value must not be falsy");return t}function u(e){const i=t.rgb(e);return[i.r/255,i.g/255,i.b/255,i.opacity]}class p extends class{constructor(t,e,i,s){this.gl=t,this.debug=s;const n=c(t.createProgram());t.attachShader(n,c(d(t,t.VERTEX_SHADER,e,s))),t.attachShader(n,c(d(t,t.FRAGMENT_SHADER,i,s))),this.program=n}link(){var t;const e=this.gl,i=this.program;if(e.linkProgram(i),this.debug){if(!e.getProgramParameter(i,e.LINK_STATUS)){const s=null!==(t=e.getProgramInfoLog(i))&&void 0!==t?t:"Unknown Error.";throw e.deleteProgram(i),new Error(s)}}}use(){this.gl.useProgram(this.program)}}{constructor(t,e){super(t,function(t){const e="\nuniform vec2 uModelScale;\nuniform vec2 uModelTranslation;\nuniform vec2 uProjectionScale;\nuniform float uLineWidth;\n\nvoid main() {\n    vec2 cssPose = uModelScale * aDataPoint + uModelTranslation;\n    vec2 dir = uModelScale * aDir;\n    dir = normalize(dir);\n    vec2 pos2d = uProjectionScale * (cssPose + vec2(-dir.y, dir.x) * uLineWidth);\n    gl_Position = vec4(pos2d, 0, 1);\n}";return t instanceof WebGLRenderingContext?"\nattribute vec2 aDataPoint;\nattribute vec2 aDir;\n"+e:"#version 300 es\nlayout (location = 0) in vec2 aDataPoint;\nlayout (location = 1) in vec2 aDir;\n"+e}(t),function(t){return t instanceof WebGLRenderingContext?"\nprecision lowp float;\nuniform vec4 uColor;\nvoid main() {\n    gl_FragColor = uColor;\n}":"#version 300 es\nprecision lowp float;\nuniform vec4 uColor;\nout vec4 outColor;\nvoid main() {\n    outColor = uColor;\n}"}(t),e),t instanceof WebGLRenderingContext&&(t.bindAttribLocation(this.program,0,"aDataPoint"),t.bindAttribLocation(this.program,1,"aDir")),this.link();const i=e=>c(t.getUniformLocation(this.program,e));this.locations={uModelScale:i("uModelScale"),uModelTranslation:i("uModelTranslation"),uProjectionScale:i("uProjectionScale"),uLineWidth:i("uLineWidth"),uColor:i("uColor")}}}const m=4*Float32Array.BYTES_PER_ELEMENT,g=131072;class f{constructor(t){this.gl=t,this.vao=c(t.createVertexArray()),this.bind()}bind(){this.gl.bindVertexArray(this.vao)}clear(){this.gl.deleteVertexArray(this.vao)}}class v{constructor(t){this.vaoExt=t,this.vao=c(t.createVertexArrayOES()),this.bind()}bind(){this.vaoExt.bindVertexArrayOES(this.vao)}clear(){this.vaoExt.deleteVertexArrayOES(this.vao)}}class x{constructor(t){this.bindFunc=t}bind(){this.bindFunc()}clear(){}}class y{constructor(t,e,i){this.gl=t,this.dataPoints=e,this.firstDataPointIndex=i,this.length=0,this.dataBuffer=c(t.createBuffer());const s=()=>{t.bindBuffer(t.ARRAY_BUFFER,this.dataBuffer),t.enableVertexAttribArray(0),t.vertexAttribPointer(0,2,t.FLOAT,!1,m,0),t.enableVertexAttribArray(1),t.vertexAttribPointer(1,2,t.FLOAT,!1,m,2*Float32Array.BYTES_PER_ELEMENT)};if(t instanceof WebGLRenderingContext){const e=t.getExtension("OES_vertex_array_object");this.vao=e?new v(e):new x(s)}else this.vao=new f(t);s(),t.bufferData(t.ARRAY_BUFFER,2097160*Float32Array.BYTES_PER_ELEMENT,t.DYNAMIC_DRAW)}clear(){this.length=0}delete(){this.clear(),this.gl.deleteBuffer(this.dataBuffer),this.vao.clear()}addDataPoints(){const t=this.dataPoints,e=this.firstDataPointIndex+this.length,i=g-this.length,s=t.length-e,n=i<s,o=n?i:s;let a=16*o;n&&(a+=8);const r=new Float32Array(a);let l=0;const d=h(),c=h(),u=h(),p=h();function f(t,e){var i,s,n;d[0]=t.x,d[1]=t.y,c[0]=e.x,c[1]=e.y,s=d,n=c,(i=u)[0]=s[0]-n[0],i[1]=s[1]-n[1],function(t,e){var i=e[0],s=e[1],n=i*i+s*s;n>0&&(n=1/Math.sqrt(n)),t[0]=e[0]*n,t[1]=e[1]*n}(u,u),function(t,e){t[0]=-e[0],t[1]=-e[1]}(p,u)}function v(t){r[l]=t[0],r[l+1]=t[1],l+=2}let x=t[e-1];for(let i=0;i<o;i++){const s=t[e+i];f(s,x),x=s;for(const t of[c,d])for(const e of[u,p])v(t),v(e)}if(n){f(t[e+o],x);for(const t of[u,p])v(c),v(t)}const y=this.gl;return y.bindBuffer(y.ARRAY_BUFFER,this.dataBuffer),y.bufferSubData(y.ARRAY_BUFFER,4*m*this.length,r),this.length+=o,e+o}draw(t){const e=Math.max(0,t.min-this.firstDataPointIndex),i=Math.min(this.length,t.max-this.firstDataPointIndex)-e,s=this.gl;this.vao.bind(),s.drawArrays(s.TRIANGLE_STRIP,4*e,4*i)}}class w{constructor(t,e){this.gl=t,this.series=e,this.vertexArrays=[]}syncBuffer(){let t,e=1;const i=()=>{t=new y(this.gl,this.series.data,e),this.vertexArrays.push(t)};if(this.vertexArrays.length>0){const i=this.vertexArrays[this.vertexArrays.length-1];if(e=i.firstDataPointIndex+i.length,e>this.series.data.length)throw new Error("remove data unsupported.");if(e===this.series.data.length)return;t=i}else{if(!(this.series.data.length>=2))return;i(),t=t}for(;;){if(e=t.addDataPoints(),e>=this.series.data.length){if(e>this.series.data.length)throw Error("Assertion failed.");break}i()}}draw(t){const e=this.series.data;if(0===this.vertexArrays.length||e[0].x>t.max||e[e.length-1].x<t.min)return;const i=t=>t.x,s=n(e,1,e.length,t.min,i),o=n(e,s,e.length-1,t.max,i)+1,a=Math.floor((s-1)/g),r=Math.ceil((o-1)/g),h={min:s,max:o};for(let t=a;t<r;t++)this.vertexArrays[t].draw(h)}}class b{constructor(t,e,i){this.model=t,this.gl=e,this.options=i,this.program=new p(this.gl,this.options.debugWebGL),this.arrays=new Map,this.height=0,this.width=0,this.program.use(),t.updated.on((()=>this.drawFrame())),t.resized.on(((t,e)=>this.onResize(t,e)))}syncBuffer(){for(const t of this.options.series){let e=this.arrays.get(t);e||(e=new w(this.gl,t),this.arrays.set(t,e)),e.syncBuffer()}}onResize(t,e){this.height=e,this.width=t;const i=(s=t,n=e,(o=new r(2))[0]=s,o[1]=n,o);var s,n,o;!function(t,e,i){t[0]=e[0]/i[0],t[1]=e[1]/i[1]}(i,i,[2,2]),function(t,e){t[0]=1/e[0],t[1]=1/e[1]}(i,i);this.gl.uniform2fv(this.program.locations.uProjectionScale,i)}drawFrame(){var t;this.syncBuffer(),this.syncDomain();const e=this.gl;for(const[i,s]of this.arrays){if(!i.visible)continue;const n=u(i.color);e.uniform4fv(this.program.locations.uColor,n);const o=null!==(t=i.lineWidth)&&void 0!==t?t:this.options.lineWidth;e.uniform1f(this.program.locations.uLineWidth,o/2);const a={min:this.model.xScale.invert(-o/2),max:this.model.xScale.invert(this.width+o/2)};s.draw(a)}if(this.options.debugWebGL){const t=e.getError();if(t!=e.NO_ERROR)throw new Error("WebGL error "+t)}}ySvgToView(t){return-t+this.height/2}xSvgToView(t){return t-this.width/2}syncDomain(){const t=this.model,e=this.gl,i=[this.xSvgToView(t.xScale(0)),this.ySvgToView(t.yScale(0))],s=[this.xSvgToView(t.xScale(1)),this.ySvgToView(t.yScale(1))],n=[s[0]-i[0],s[1]-i[1]];e.uniform2fv(this.program.locations.uModelScale,n),e.uniform2fv(this.program.locations.uModelTranslation,i)}}class S{constructor(t,e,i){this.options=e;const s=document.createElement("canvas");s.style.width="100%",s.style.height="100%",s.style.position="absolute",t.shadowRoot.appendChild(s),this.gl=function(t,e){if(!e){const e=t.getContext("webgl2");if(e)return e}const i=t.getContext("webgl");if(i)return i;throw new Error("Unable to initialize WebGL. Your browser or machine may not support it.")}(s,e.forceWebGL1);const n=u(e.backgroundColor);this.gl.clearColor(...n),this.canvas=s,i.updated.on((()=>this.clear())),i.resized.on(((t,e)=>this.onResize(t,e))),i.disposing.on((()=>{t.shadowRoot.removeChild(s),s.width=0,s.height=0;const e=this.gl.getExtension("WEBGL_lose_context");e&&e.loseContext()}))}onResize(t,e){const i=this.canvas,s=this.options.pixelRatio;i.width=t*s,i.height=e*s,this.gl.viewport(0,0,i.width,i.height)}clear(){const t=this.gl;t.clear(t.COLOR_BUFFER_BIT)}}class E{constructor(t,e){this.svgNode=document.createElementNS("http://www.w3.org/2000/svg","svg"),this.svgNode.style.position="absolute",this.svgNode.style.width="100%",this.svgNode.style.height="100%",t.shadowRoot.appendChild(this.svgNode),e.disposing.on((()=>{t.shadowRoot.removeChild(this.svgNode)}))}}class R{constructor(t,e,i){this.node=document.createElement("div"),this.node.style.position="absolute",this.node.style.left=i.paddingLeft+"px",this.node.style.right=i.paddingRight+"px",this.node.style.top=i.paddingTop+"px",this.node.style.bottom=i.paddingBottom+"px",t.shadowRoot.appendChild(this.node),e.disposing.on((()=>{t.shadowRoot.removeChild(this.node)}))}}function P(t){const e=t.domain(),i=t.range();return(e[1]-e[0])/(i[1]-i[0])}function T(t,e){const i=e[1]-e[0],s=t.scale.domain();if((s[1]-s[0])*i<=0)return!1;const n=Math.min(t.maxDomainExtent,t.maxDomain-t.minDomain,Math.max(t.minDomainExtent,i)),o=(n-i)/2;e[0]-=o,e[1]+=o;const a=Math.min(Math.max(t.minDomain-e[0],0),t.maxDomain-e[1]);e[0]+=a,e[1]+=a;const r=1e-6*n;return t.scale.domain(e),!!function(...t){return[...t[0]].map(((e,i)=>t.map((t=>t[i]))))}(e,s).some((([t,e])=>Math.abs(t-e)>r))}function L(t,e,i){return t>i?i:t<e?e:t}var C;function M(t){return[{dir:C.X,op:t.x},{dir:C.Y,op:t.y}].filter((t=>void 0!==t.op))}R.meta={name:"contentBoxDetector",required:["wrapper","options"],optional:["svgLayer","canvasLayer"]},function(t){t[t.UNKNOWN=0]="UNKNOWN",t[t.X=1]="X",t[t.Y=2]="Y"}(C||(C={}));class A{constructor(t,e){this.el=t,this.options=e,this.scaleUpdated=new o,this.majorDirection=C.UNKNOWN,this.previousPoints=new Map,this.enabled={[C.X]:!1,[C.Y]:!1},t.addEventListener("touchstart",(t=>this.onTouchStart(t)),{passive:!0}),t.addEventListener("touchend",(t=>this.onTouchEnd(t)),{passive:!0}),t.addEventListener("touchcancel",(t=>this.onTouchEnd(t)),{passive:!0}),t.addEventListener("touchmove",(t=>this.onTouchMove(t)),{passive:!0}),this.update()}update(){this.syncEnabled(),this.syncTouchAction()}syncEnabled(){for(const{dir:t,op:e}of M(this.options))if(e){const i=e.scale.domain().sort();this.enabled[t]=e.minDomain<i[0]&&i[1]<e.maxDomain}else this.enabled[t]=!1}syncTouchAction(){const t=[];this.enabled[C.X]||t.push("pan-x"),this.enabled[C.Y]||t.push("pan-y"),0===t.length&&t.push("none"),this.el.style.touchAction=t.join(" ")}calcKB(t,e,i){if(t===this.majorDirection&&i.length>=2){const t=e.scale.domain(),s=t[1]-t[0];if(function(t){const e=t.reduce(((t,e)=>t+e))/t.length;return t.map((t=>(t-e)**2)).reduce(((t,e)=>t+e))/t.length}(i.map((t=>t.domain)))>1e-4*s*s)return function(t){let e=0,i=0,s=0,n=0;const o=t.length;for(const o of t)e+=o.x,i+=o.y,s+=o.x*o.y,n+=o.x*o.x;const a=o*n-e*e,r=0===a?0:(o*s-e*i)/a;return{k:r,b:(i-r*e)/o}}(i.map((t=>({x:t.current,y:t.domain}))))}const s=P(e.scale),n=i.map((t=>t.domain-s*t.current)).reduce(((t,e)=>t+e))/i.length;return{k:s,b:n}}touchPoints(t){const e=this.el.getBoundingClientRect(),i=new Map([...t].map((t=>[t.identifier,{[C.X]:t.clientX-e.left,[C.Y]:t.clientY-e.top}])));let s=!1;for(const{dir:t,op:e}of M(this.options)){const n=e.scale,o=[...i.entries()].map((([e,i])=>({current:i[t],previousPoint:this.previousPoints.get(e)}))).filter((t=>void 0!==t.previousPoint)).map((({current:e,previousPoint:i})=>({current:e,domain:n.invert(i[t])})));if(0===o.length)continue;const{k:a,b:r}=this.calcKB(t,e,o);T(e,n.range().map((t=>r+a*t)))&&(s=!0)}return this.previousPoints=i,s&&this.scaleUpdated.dispatch(),s}dirOptions(t){return{[C.X]:this.options.x,[C.Y]:this.options.y}[t]}onTouchStart(t){if(this.majorDirection===C.UNKNOWN&&t.touches.length>=2){const i=[...t.touches];function e(t){const e=t.reduce(((t,e)=>t+e))/t.length;return t.map((t=>(t-e)**2)).reduce(((t,e)=>t+e))}const s=e(i.map((t=>t.clientX))),n=e(i.map((t=>t.clientY)));this.majorDirection=s>n?C.X:C.Y,void 0===this.dirOptions(this.majorDirection)&&(this.majorDirection=C.UNKNOWN)}this.touchPoints(t.touches)}onTouchEnd(t){t.touches.length<2&&(this.majorDirection=C.UNKNOWN),this.touchPoints(t.touches)}onTouchMove(t){this.touchPoints(t.touches)}}class N{constructor(t,e){this.el=t,this.options=e,this.scaleUpdated=new o,t.addEventListener("wheel",(t=>this.onWheel(t)))}onWheel(t){t.preventDefault();let e=t.deltaX,i=t.deltaY;switch(t.deltaMode){case 1:e*=30,i*=30;break;case 2:e*=400,i*=400}const s={[C.X]:{translate:0,zoom:0},[C.Y]:{translate:0,zoom:0}};t.ctrlKey?t.altKey?(s[C.X].zoom=e,s[C.Y].zoom=i):s[C.X].zoom=e+i:t.altKey?(s[C.X].translate=e,s[C.Y].translate=i):s[C.X].translate=e+i;const n=this.el.getBoundingClientRect(),o={[C.X]:t.clientX-n.left,[C.Y]:t.clientY-n.top};let a=!1;for(const{dir:e,op:i}of M(this.options)){const n=i.scale.domain(),r=P(i.scale),h=s[e],l=i.scale.invert(o[e]);h.translate*=r,h.zoom*=.002,t.shiftKey&&(h.translate*=5,h.zoom*=5);const d=.4*(n[1]-n[0]);h.translate=L(h.translate,-d,d);const c=.5;h.zoom=L(h.zoom,-c,c);T(i,n.map((t=>t+h.translate+(t-l)*h.zoom)))&&(a=!0)}a&&this.scaleUpdated.dispatch()}}class D{constructor(t,e){this.el=t,this.options=e,this.scaleUpdated=new o,this.previousPoint=null,t.style.userSelect="none",t.addEventListener("pointerdown",(t=>this.onMouseDown(t))),t.addEventListener("pointerup",(t=>this.onMouseUp(t))),t.addEventListener("pointermove",(t=>this.onMouseMove(t)))}point(t){const e=this.el.getBoundingClientRect();return{[C.X]:t.clientX-e.left,[C.Y]:t.clientY-e.top}}onMouseMove(t){if(null===this.previousPoint)return;const e=this.point(t);let i=!1;for(const{dir:t,op:s}of M(this.options)){const n=e[t]-this.previousPoint[t],o=P(s.scale),a=s.scale.domain();T(s,a.map((t=>t-o*n)))&&(i=!0)}this.previousPoint=e,i&&this.scaleUpdated.dispatch()}onMouseDown(t){"mouse"===t.pointerType&&(this.el.setPointerCapture(t.pointerId),this.previousPoint=this.point(t),this.el.style.cursor="grabbing")}onMouseUp(t){null!==this.previousPoint&&(this.previousPoint=null,this.el.releasePointerCapture(t.pointerId),this.el.style.cursor="")}}const j={minDomain:-1/0,maxDomain:1/0,minDomainExtent:0,maxDomainExtent:1/0};class B{constructor(t,e){this.scaleUpdated=new o,e=null!=e?e:{},this.options={x:e.x&&Object.assign(Object.assign({},j),e.x),y:e.y&&Object.assign(Object.assign({},j),e.y)},this.touch=new A(t,this.options),this.mouse=new D(t,this.options),this.wheel=new N(t,this.options);const i=()=>this.scaleUpdated.dispatch();this.touch.scaleUpdated.on(i),this.mouse.scaleUpdated.on(i),this.wheel.scaleUpdated.on(i)}onScaleUpdated(t){this.scaleUpdated.on(t)}update(){this.touch.update()}}class O{constructor(t,e,n){this.model=t,this.options=n,this.xAxis=s.axisBottom(this.model.xScale),this.yAxis=s.axisLeft(this.model.yScale);const o=i.select(e);this.xg=o.append("g"),this.yg=o.append("g"),t.updated.on((()=>this.update())),t.resized.on(((t,e)=>this.onResize(t,e)))}update(){const t=this.model.xScale,e=this.options.xScaleType().domain(t.domain().map((t=>t+this.options.baseTime))).range(t.range());this.xAxis.scale(e),this.xg.call(this.xAxis),this.yAxis.scale(this.model.yScale),this.yg.call(this.yAxis)}onResize(t,e){const i=this.options;this.xg.attr("transform",`translate(0, ${e-i.paddingBottom})`),this.yg.attr("transform",`translate(${i.paddingLeft}, 0)`),this.update()}}class U{constructor(t,e,i){this.el=t,this.model=e,this.options=i,this.items=new Map,this.legend=document.createElement("chart-legend");const s=this.legend.style;s.position="absolute",s.right=i.paddingRight+"px",s.top=i.paddingTop+"px";const n=this.legend.attachShadow({mode:"open"}),o=document.createElement("style");o.textContent="\n:host {\n    background: var(--background-overlay, white);\n    border: 1px solid hsl(0, 0%, 80%);\n    border-radius: 3px;\n    padding: 5px 10px;\n}\n.item {\n    display: flex;\n    flex-flow: row nowrap;\n    align-items: center;\n    user-select: none;\n}\n.item:not(.visible) {\n    color: gray;\n    text-decoration: line-through;\n}\n.item .example {\n    width: 50px;\n    margin-right: 10px;\n    max-height: 1em;\n}",n.appendChild(o),this.itemContainer=n,this.update(),t.shadowRoot.appendChild(this.legend),e.updated.on((()=>this.update())),e.disposing.on((()=>{t.shadowRoot.removeChild(this.legend)}))}update(){var t;for(const e of this.options.series){if(!this.items.has(e)){const t=document.createElement("div");t.className="item";const i=document.createElement("div");i.className="example",t.appendChild(i);const s=document.createElement("label");s.textContent=e.name,t.appendChild(s),this.itemContainer.appendChild(t),t.addEventListener("click",(t=>{e.visible=!e.visible,this.model.update()})),this.items.set(e,{item:t,example:i})}const i=this.items.get(e);i.item.classList.toggle("visible",e.visible),i.example.style.height=(null!==(t=e.lineWidth)&&void 0!==t?t:this.options.lineWidth)+"px",i.example.style.backgroundColor=e.color.toString()}}}class z{constructor(t,e,i,s){const n=function(t,e){const i=document.createElementNS("http://www.w3.org/2000/svg","svg");return i.classList.add("content-box"),i.x.baseVal.value=e.paddingLeft,i.y.baseVal.value=e.paddingRight,t.resized.on(((t,s)=>{i.width.baseVal.value=t-e.paddingRight-e.paddingLeft,i.height.baseVal.value=s-e.paddingTop-e.paddingBottom})),i}(e,i),o=n.createSVGTransform();o.setTranslate(0,0);const a=document.createElementNS("http://www.w3.org/2000/svg","style");a.textContent="\n.timechart-crosshair {\n    stroke: currentColor;\n    stroke-width: 1;\n    stroke-dasharray: 2 1;\n    visibility: hidden;\n}";const r=document.createElementNS("http://www.w3.org/2000/svg","line");r.transform.baseVal.initialize(o),r.x2.baseVal.newValueSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PERCENTAGE,100);const h=document.createElementNS("http://www.w3.org/2000/svg","line");h.transform.baseVal.initialize(o),h.y2.baseVal.newValueSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PERCENTAGE,100);const l=document.createElementNS("http://www.w3.org/2000/svg","g");l.classList.add("timechart-crosshair");for(const t of[a,r,h])l.appendChild(t);s.node.addEventListener("mousemove",(t=>{const e=n.getBoundingClientRect();r.transform.baseVal.getItem(0).setTranslate(0,t.clientY-e.y),h.transform.baseVal.getItem(0).setTranslate(t.clientX-e.x,0)})),s.node.addEventListener("mouseenter",(t=>l.style.visibility="visible")),s.node.addEventListener("mouseleave",(t=>l.style.visibility="hidden")),n.appendChild(l),t.svgNode.appendChild(n)}}z.meta={name:"crosshair",required:["svgLayer","model","options","contentBoxDetector"]};class V{constructor(t,e,i,s){this.canvas=t,this.model=e,this.options=i,this.points=new Map,this.lastX=null,this.updated=new o,s.node.addEventListener("mousemove",(e=>{const i=t.canvas.getBoundingClientRect();this.lastX=e.clientX-i.left,this.adjustPoints()})),s.node.addEventListener("mouseleave",(t=>{this.lastX=null,this.adjustPoints()})),e.updated.on((()=>this.adjustPoints()))}adjustPoints(){if(null===this.lastX)this.points.clear();else{const t=this.model.xScale.invert(this.lastX);for(const e of this.options.series){if(0==e.data.length||!e.visible){this.points.delete(e);continue}const i=n(e.data,0,e.data.length,t,(t=>t.x)),s=[];i>0&&s.push(e.data[i-1]),i<e.data.length&&s.push(e.data[i]);const o=e=>Math.abs(e.x-t);s.sort(((t,e)=>o(t)-o(e)));const a=this.model.pxPoint(s[0]),r=this.canvas.canvas.clientWidth,h=this.canvas.canvas.clientHeight;a.x<=r&&a.x>=0&&a.y<=h&&a.y>=0?this.points.set(e,a):this.points.delete(e)}}this.updated.dispatch()}}V.meta={name:"nearestPointModel",required:["canvasLayer","model","options","contentBoxDetector"]};class W{constructor(t,e,i){this.svg=t,this.options=e,this.pModel=i,this.intersectPoints=new Map;t.svgNode.createSVGTransform().setTranslate(0,0);const s=document.createElementNS("http://www.w3.org/2000/svg","style");s.textContent="\n.timechart-crosshair-intersect {\n    fill: var(--background-overlay, white);\n    visibility: hidden;\n}\n.timechart-crosshair-intersect circle {\n    r: 3px;\n}";const n=document.createElementNS("http://www.w3.org/2000/svg","g");n.classList.add("timechart-crosshair-intersect"),n.appendChild(s),this.container=n,this.adjustIntersectPoints(),t.svgNode.appendChild(n),i.updated.on((()=>this.adjustIntersectPoints()))}adjustIntersectPoints(){var t;const e=this.svg.svgNode.createSVGTransform();e.setTranslate(0,0);for(const i of this.options.series){if(!this.intersectPoints.has(i)){const s=document.createElementNS("http://www.w3.org/2000/svg","circle");s.style.stroke=i.color.toString(),s.style.strokeWidth=(null!==(t=i.lineWidth)&&void 0!==t?t:this.options.lineWidth)+"px",s.transform.baseVal.initialize(e),this.container.appendChild(s),this.intersectPoints.set(i,s)}const s=this.intersectPoints.get(i),n=this.pModel.points.get(i);n?(s.style.visibility="visible",s.transform.baseVal.getItem(0).setTranslate(n.x,n.y)):s.style.visibility="hidden"}}}W.meta={name:"nearestPoint",required:["svgLayer","options","nearestPointModel"]};const _={pixelRatio:window.devicePixelRatio,lineWidth:1,backgroundColor:t.rgb(0,0,0,0),paddingTop:10,paddingRight:10,paddingLeft:45,paddingBottom:20,xRange:"auto",yRange:"auto",realTime:!1,baseTime:0,xScaleType:e.scaleTime,debugWebGL:!1,forceWebGL1:!1},Y={name:"",visible:!0};return class{constructor(t,e){var i,s,n;this.el=t,this.disposed=!1;const o=null!==(s=null===(i=(e=null!=e?e:{}).series)||void 0===i?void 0:i.map((t=>this.completeSeriesOptions(t))))&&void 0!==s?s:[],r=Object.assign(Object.assign(Object.assign({},_),e),{series:o});this.model=new a(r);const h=null!==(n=t.shadowRoot)&&void 0!==n?n:t.attachShadow({mode:"open"}),l=document.createElement("style");l.innerText="\n:host {\n    contain: size layout paint style;\n    position: relative;\n}",h.appendChild(l);const d=new S(t,r,this.model),c=(new b(this.model,d.gl,r),new E(t,this.model)),u=new R(t,this.model,r),p=(new O(this.model,c.svgNode,r),new U(t,this.model,r),new z(c,this.model,r,u),new V(d,this.model,r,u));new W(c,r,p);this.options=Object.assign(r,{zoom:this.registerZoom(u.node,e.zoom)}),this.onResize();const m=()=>this.onResize();window.addEventListener("resize",m),this.model.disposing.on((()=>{window.removeEventListener("resize",m),h.removeChild(l)}))}completeSeriesOptions(t){return Object.assign(Object.assign(Object.assign(Object.assign({data:[]},Y),{color:getComputedStyle(this.el).getPropertyValue("color")}),t),{_complete:!0})}registerZoom(t,e){if(e){const i=new B(t,{x:e.x&&Object.assign(Object.assign({},e.x),{scale:this.model.xScale}),y:e.y&&Object.assign(Object.assign({},e.y),{scale:this.model.yScale})}),s=i.options;return this.model.updated.on((()=>{const t=[[s.x,this.model.xScale,this.model.xRange],[s.y,this.model.yScale,this.model.yRange]];for(const[e,i,s]of t){if(!(null==e?void 0:e.autoRange))continue;let[t,n]=i.domain();s&&(t=Math.min(t,s.min),n=Math.max(n,s.max)),e.minDomain=t,e.maxDomain=n}i.update()})),i.onScaleUpdated((()=>{this.options.xRange=null,this.options.yRange=null,this.options.realTime=!1,this.update()})),s}}onResize(){this.model.resize(this.el.clientWidth,this.el.clientHeight)}update(){if(this.disposed)throw new Error("Cannot update after dispose.");for(let t=0;t<this.options.series.length;t++){const e=this.options.series[t];e._complete||(this.options.series[t]=this.completeSeriesOptions(e))}this.model.requestRedraw()}dispose(){this.model.dispose(),this.disposed=!0}}}));
//# sourceMappingURL=timechart.min.js.map
